import React, { useEffect, useState, useMemo, useContext } from "react";
import {
  View,
  Text,
  TouchableOpacity,
  Image,
  Dimensions,
  ScrollView,
  Modal,
  Alert,
  Animated,
  RefreshControl,
} from "react-native";
import { useRouter, useLocalSearchParams } from "expo-router";
import { Ionicons } from "@expo/vector-icons";
import orderStatusStyles, { ORDER_STATUS_COLORS } from "./src/OrderStatus.js";
import { getItemById } from "./demodata/menuDemoData.js";
import { OrderContext } from "./context/OrderContext";
import { supabase } from "../lib/supabase";
import { useAuth } from "./context/AuthContext";

const { width } = Dimensions.get("window");

export default function OrderStatus() {
  const router = useRouter();
  const params = useLocalSearchParams();
  const { createOrder, getTimeRemaining, getEstimatedReadyTime, clearOrder } =
    useContext(OrderContext);
  const { user } = useAuth();

  const {
    id = "1",
    time = new Date().toISOString(),
    status = "pending",
    items = "[]",
    total = "0",
    payment = "Cash",
    orderNumber = null, // ✅ Get orderNumber from params
  } = params;

  // ✅ REMOVED: Don't generate order number here - use the one from params
  // If no orderNumber in params, it will be generated by OrderContext.createOrder()

  // Parse order items safely with menu data lookup
  const orderItems = useMemo(() => {
    try {
      const decoded =
        typeof items === "string" ? decodeURIComponent(items) : items;
      const parsed =
        typeof decoded === "string" ? JSON.parse(decoded) : decoded;

      if (!Array.isArray(parsed)) return [];

      return parsed.map((item) => {
        // Get full item data from menu
        const menuItem = getItemById(item.id);

        return {
          ...item,
          quantity: Number(item.quantity) || 1,
          price: Number(item.price) || 0,
          prep_time: menuItem ? menuItem.prep_time : 15, // fallback to 15 min if not found
          name: menuItem ? menuItem.name : item.name,
          image: menuItem ? menuItem.image : item.image,
        };
      });
    } catch {
      return [];
    }
  }, [items]);

  // Parse order time
  const orderTime = useMemo(() => {
    const parsed = Date.parse(time);
    return !isNaN(parsed) ? new Date(parsed) : new Date();
  }, [time]);

  // Calculate ETA based on actual prep times
  const calculateETA = useMemo(() => {
    if (orderItems.length === 0) return 15; // Default 15 minutes if no items

    // Find the maximum prep time among all items (since they can be prepared in parallel)
    const maxPrepTime = Math.max(...orderItems.map((item) => item.prep_time));

    // Add base queue/setup time (2-5 minutes depending on queue position)
    const orderPosition = Number(id) || 1;
    const queueTime = Math.min(2 + (orderPosition - 1) * 2, 10); // Max 10 min queue time

    // Total ETA is max prep time + queue time
    return maxPrepTime + queueTime;
  }, [orderItems, id]);

  const estimatedReadyTime = useMemo(
    () => new Date(orderTime.getTime() + calculateETA * 60000),
    [orderTime, calculateETA]
  );

  // State management
  const [remaining, setRemaining] = useState(0);
  const [orderStatus, setOrderStatus] = useState("pending"); // Force default to pending
  const [showCancelModal, setShowCancelModal] = useState(false);
  const [showReasonModal, setShowReasonModal] = useState(false);
  const [selectedReason, setSelectedReason] = useState("");
  const [currentOrderNumber, setCurrentOrderNumber] = useState(orderNumber || (id ? `NU-2025-${id}` : null)); // ✅ Use NU-2025-{order_id} fallback
  const [refreshing, setRefreshing] = useState(false);
  const [paymentStatus, setPaymentStatus] = useState("pending");

  // Animation for sliding to bottom
  const slideAnim = new Animated.Value(0);

  // Function to fetch latest order status from database
  const fetchOrderStatus = async () => {
    try {
      if (!user?.id || !id) return;

      // Fetch order status
      const { data: orderData, error: orderError } = await supabase
        .from('orders')
        .select('status, updated_at')
        .eq('order_id', Number(id))
        .eq('user_id', user.id)
        .single();

      if (orderError) {
        console.error('Error fetching order status:', orderError);
        return;
      }

      if (orderData) {
        // Map database status to app status
        const dbStatusMap = {
          'Pending': 'pending',
          'Preparing': 'preparing',
          'Ready': 'ready',
          'Completed': 'received',
          'Cancelled': 'cancelled'
        };
        
        const newStatus = dbStatusMap[orderData.status] || orderData.status.toLowerCase();
        setOrderStatus(newStatus);
      }

      // Fetch payment status
      const { data: paymentData, error: paymentError } = await supabase
        .from('payments')
        .select('status, provider_intent_id, provider_reference')
        .eq('order_id', Number(id))
        .eq('user_id', user.id)
        .maybeSingle();

      if (!paymentError && paymentData) {
        setPaymentStatus(paymentData.status);
      }
    } catch (error) {
      console.error('Error in fetchOrderStatus:', error);
    }
  };

  // Pull to refresh handler
  const onRefresh = async () => {
    setRefreshing(true);
    await fetchOrderStatus();
    setRefreshing(false);
  };

  // Initialize order in context and set up countdown
  useEffect(() => {
    const orderData = {
      id,
      items: orderItems,
      total: parseFloat(total),
      payment,
      status: orderStatus,
      time,
      prepTime: calculateETA,
      orderNumber: currentOrderNumber, // ✅ Pass the existing order number (or null to generate new one)
    };

    // ✅ Create order and get the final order with generated number if needed
    const finalOrder = createOrder(orderData);

    // ✅ If we didn't have an order number, store the generated one
    if (!currentOrderNumber && finalOrder.orderNumber) {
      setCurrentOrderNumber(finalOrder.orderNumber);
    }

    // Fetch initial order status from database
    fetchOrderStatus();
  }, []);

  // Auto-refresh order status every 10 seconds
  useEffect(() => {
    const interval = setInterval(() => {
      fetchOrderStatus();
    }, 10000); // Refresh every 10 seconds

    return () => clearInterval(interval);
  }, [id, user]);

  // Update countdown using context method
  useEffect(() => {
    if (orderStatus === "preparing") {
      const updateCountdown = () => {
        const timeLeft = getTimeRemaining();
        setRemaining(timeLeft);
      };

      // Update immediately
      updateCountdown();

      // Then update every second
      const interval = setInterval(updateCountdown, 1000);
      return () => clearInterval(interval);
    }
  }, [orderStatus, getTimeRemaining]);

  // Handle back navigation with order state preservation
  const handleBackNavigation = () => {
    // Update the order in context with current status
    const orderData = {
      id,
      items: orderItems,
      total: parseFloat(total),
      payment,
      status: orderStatus,
      time,
      prepTime: calculateETA,
      orderNumber: currentOrderNumber, // ✅ Use the stored order number
    };

    createOrder(orderData);

    // Animate sliding down before navigation
    Animated.timing(slideAnim, {
      toValue: 1,
      duration: 300,
      useNativeDriver: true,
    }).start(() => {
      router.replace({
        pathname: "/Menu",
        params: {
          fromOrderStatus: "true",
          // Pass order details as backup params
          orderId: id,
          orderStatus: orderStatus,
          orderTime: time,
          orderItems: encodeURIComponent(JSON.stringify(orderItems)),
          orderTotal: total,
          paymentMethod: payment,
          orderNumber: currentOrderNumber, // ✅ Pass the stored order number
        },
      });
    });
  };

  // Override hardware back button
  useEffect(() => {
    const backHandler = () => {
      handleBackNavigation();
      return true; // Prevent default back behavior
    };

    // Add event listener for hardware back button (Android)
    if (typeof window !== "undefined" && window.addEventListener) {
      window.addEventListener("beforeunload", backHandler);
    }

    return () => {
      if (typeof window !== "undefined" && window.removeEventListener) {
        window.removeEventListener("beforeunload", backHandler);
      }
    };
  }, []);

  const formatTime = (seconds) => {
    const m = Math.floor(seconds / 60);
    const s = seconds % 60;
    return `${m}:${s < 10 ? "0" : ""}${s}`;
  };

  const formatEstimatedTime = () => {
    const readyTime = getEstimatedReadyTime();
    if (!readyTime) return "N/A";

    return readyTime.toLocaleTimeString([], {
      hour: "2-digit",
      minute: "2-digit",
      hour12: true,
    });
  };

  // Check if order can be cancelled (within 5 minutes)
  const canCancelOrder = () => {
    const currentTime = new Date();
    const timeDiff = (currentTime - orderTime) / 1000 / 60; // minutes
    return (
      timeDiff <= 5 &&
      (orderStatus === "preparing" || orderStatus === "pending")
    );
  };

  // Cancel order handlers
  const handleCancelOrder = () => {
    if (canCancelOrder()) {
      setShowCancelModal(true);
    } else {
      Alert.alert(
        "Cannot Cancel",
        "Orders can only be cancelled within 5 minutes of ordering."
      );
    }
  };

  const confirmCancelOrder = () => {
    setShowCancelModal(false);
    setShowReasonModal(true);
  };

  const submitCancellation = async () => {
    if (!selectedReason) {
      Alert.alert(
        "Please select a reason",
        "Please provide a reason for cancelling your order."
      );
      return;
    }

    try {
      if (!user?.id) throw new Error("Not authenticated");

      // 1) Update order to Cancelled for this user (guard by user_id via RLS)
      const { error: orderErr } = await supabase
        .from("orders")
        .update({ status: "Cancelled" })
        .eq("order_id", Number(id));
      if (orderErr) throw orderErr;

      // 2) Update related payment to cancelled
      const { data: paymentRow, error: fetchPayErr } = await supabase
        .from("payments")
        .select("payment_id, status")
        .eq("order_id", Number(id))
        .eq("user_id", user.id)
        .maybeSingle();
      if (fetchPayErr) throw fetchPayErr;

      if (paymentRow?.payment_id) {
        const { error: payErr } = await supabase
          .from("payments")
          .update({ status: "cancelled" })
          .eq("payment_id", paymentRow.payment_id);
        if (payErr) throw payErr;

        // 3) Log payment event (client-side insert allowed by RLS)
        await supabase.from("payment_events").insert({
          payment_id: paymentRow.payment_id,
          provider: null,
          event_type: "client.cancelled",
          event_payload: { reason: selectedReason },
        });
      }

      // 4) Insert cancellation reason into order_cancellations table
      const { error: cancelErr } = await supabase
        .from("order_cancellations")
        .insert({
          order_id: Number(id),
          user_id: user.id,
          reason: selectedReason,
        });
      if (cancelErr) {
        console.error("Failed to log cancellation reason:", cancelErr);
        // Don't throw - cancellation already processed
      }

      setOrderStatus("cancelled");
      setShowReasonModal(false);
      
      // Clear order from context so it doesn't show in Menu
      clearOrder();
      
      Alert.alert(
        "Order Cancelled",
        "Your order has been cancelled successfully.",
        [
          {
            text: "OK",
            onPress: () => router.replace("/Menu"),
          },
        ]
      );
    } catch (e) {
      console.error("Cancellation failed", e);
      Alert.alert("Error", "Failed to cancel order. Please try again.");
    }
  };

  const cancelReasons = [
    "Changed my mind",
    "Found a better option",
    "Taking too long",
    "Emergency came up",
    "Wrong items ordered",
    "Other",
  ];

  // Render order status display
  const renderOrderStatus = () => {
    switch (orderStatus) {
      case "pending":
        return (
          <>
            <Text style={orderStatusStyles.orderStatusEtaText}>PENDING</Text>
            <Text style={orderStatusStyles.orderStatusEtaLabel}>
              Your order is being confirmed
            </Text>
          </>
        );
      case "preparing":
        return (
          <>
            <Text style={orderStatusStyles.orderStatusEtaText}>
              {formatTime(remaining)}
            </Text>
            <Text style={orderStatusStyles.orderStatusEtaLabel}>
              Estimated ready by {formatEstimatedTime()}
            </Text>
          </>
        );
      case "ready":
        return (
          <>
            <Text style={orderStatusStyles.orderStatusEtaText}>READY!</Text>
            <Text style={orderStatusStyles.orderStatusEtaLabel}>
              You can now pick up your order
            </Text>
          </>
        );
      case "received":
        return (
          <>
            <Text style={orderStatusStyles.orderStatusEtaText}>RECEIVED!</Text>
            <Text style={orderStatusStyles.orderStatusEtaLabel}>
              Order has been received
            </Text>
          </>
        );
      case "cancelled":
        return (
          <>
            <Text
              style={[
                orderStatusStyles.orderStatusEtaText,
                { color: ORDER_STATUS_COLORS.danger },
              ]}
            >
              CANCELLED
            </Text>
            <Text style={orderStatusStyles.orderStatusEtaLabel}>
              Your order is cancelled
            </Text>
          </>
        );
      default:
        return (
          <>
            <Text style={orderStatusStyles.orderStatusEtaText}>
              {formatTime(remaining)}
            </Text>
            <Text style={orderStatusStyles.orderStatusEtaLabel}>
              Estimated ready by {formatEstimatedTime()}
            </Text>
          </>
        );
    }
  };

  // Render progress steps
  const renderProgressSteps = () => {
    return (
      <View style={orderStatusStyles.orderStatusProgress}>
        <View style={orderStatusStyles.orderStatusStep}>
          <View
            style={[
              orderStatusStyles.orderStatusDot,
              orderStatus === "pending" && {
                backgroundColor: ORDER_STATUS_COLORS.orange,
              },
            ]}
          />
          <Text
            style={[
              orderStatusStyles.orderStatusStepText,
              orderStatus === "pending" && {
                fontWeight: "bold",
                color: ORDER_STATUS_COLORS.primary,
              },
            ]}
          >
            Your order is pending
          </Text>
        </View>
        <View style={orderStatusStyles.orderStatusStep}>
          <View
            style={[
              orderStatusStyles.orderStatusDot,
              orderStatus === "preparing" && {
                backgroundColor: ORDER_STATUS_COLORS.orange,
              },
            ]}
          />
          <Text
            style={[
              orderStatusStyles.orderStatusStepText,
              orderStatus === "preparing" && {
                fontWeight: "bold",
                color: ORDER_STATUS_COLORS.primary,
              },
            ]}
          >
            Your order is being prepared
          </Text>
        </View>
        <View style={orderStatusStyles.orderStatusStep}>
          <View
            style={[
              orderStatusStyles.orderStatusDot,
              orderStatus === "ready" && {
                backgroundColor: ORDER_STATUS_COLORS.green,
              },
            ]}
          />
          <Text
            style={[
              orderStatusStyles.orderStatusStepText,
              orderStatus === "ready" && {
                fontWeight: "bold",
                color: ORDER_STATUS_COLORS.primary,
              },
            ]}
          >
            You can now pick up your order
          </Text>
        </View>
        <View style={orderStatusStyles.orderStatusStep}>
          <View
            style={[
              orderStatusStyles.orderStatusDot,
              orderStatus === "received" && {
                backgroundColor: ORDER_STATUS_COLORS.green,
              },
            ]}
          />
          <Text
            style={[
              orderStatusStyles.orderStatusStepText,
              orderStatus === "received" && {
                fontWeight: "bold",
                color: ORDER_STATUS_COLORS.primary,
              },
            ]}
          >
            Order has been received
          </Text>
        </View>
        {orderStatus === "cancelled" && (
          <View style={orderStatusStyles.orderStatusStep}>
            <View
              style={[
                orderStatusStyles.orderStatusDot,
                { backgroundColor: ORDER_STATUS_COLORS.danger },
              ]}
            />
            <Text
              style={[
                orderStatusStyles.orderStatusStepText,
                { fontWeight: "bold", color: ORDER_STATUS_COLORS.danger },
              ]}
            >
              Your order is cancelled
            </Text>
          </View>
        )}
      </View>
    );
  };

  // Render cancel confirmation modal
  const renderCancelModal = () => (
    <Modal
      animationType="fade"
      transparent={true}
      visible={showCancelModal}
      onRequestClose={() => setShowCancelModal(false)}
    >
      <View style={orderStatusStyles.modalOverlay}>
        <View style={orderStatusStyles.modalContainer}>
          <Text style={orderStatusStyles.modalTitle}>Cancel Order</Text>
          <Text style={orderStatusStyles.modalText}>
            Are you sure you want to cancel your order?
          </Text>
          <View style={orderStatusStyles.modalButtons}>
            <TouchableOpacity
              style={[
                orderStatusStyles.modalButton,
                orderStatusStyles.modalCancelButton,
              ]}
              onPress={() => setShowCancelModal(false)}
            >
              <Text style={orderStatusStyles.modalCancelText}>No</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[
                orderStatusStyles.modalButton,
                orderStatusStyles.modalConfirmButton,
              ]}
              onPress={confirmCancelOrder}
            >
              <Text style={orderStatusStyles.modalConfirmText}>Yes</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );

  // Render reason selection modal
  const renderReasonModal = () => (
    <Modal
      animationType="slide"
      transparent={true}
      visible={showReasonModal}
      onRequestClose={() => setShowReasonModal(false)}
    >
      <View style={orderStatusStyles.modalOverlay}>
        <View style={orderStatusStyles.modalContainer}>
          <Text style={orderStatusStyles.modalTitle}>
            Reason for Cancellation
          </Text>
          <Text style={orderStatusStyles.modalText}>
            Please select a reason for cancelling your order:
          </Text>
          <ScrollView style={orderStatusStyles.reasonsList}>
            {cancelReasons.map((reason, index) => (
              <TouchableOpacity
                key={index}
                style={[
                  orderStatusStyles.reasonItem,
                  selectedReason === reason &&
                    orderStatusStyles.reasonItemSelected,
                ]}
                onPress={() => setSelectedReason(reason)}
              >
                <View style={orderStatusStyles.radioContainer}>
                  <View style={orderStatusStyles.radioCircle}>
                    {selectedReason === reason && (
                      <View style={orderStatusStyles.radioDot} />
                    )}
                  </View>
                  <Text style={orderStatusStyles.reasonText}>{reason}</Text>
                </View>
              </TouchableOpacity>
            ))}
          </ScrollView>
          <View style={orderStatusStyles.modalButtons}>
            <TouchableOpacity
              style={[
                orderStatusStyles.modalButton,
                orderStatusStyles.modalCancelButton,
              ]}
              onPress={() => {
                setShowReasonModal(false);
                setSelectedReason("");
              }}
            >
              <Text style={orderStatusStyles.modalCancelText}>Cancel</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[
                orderStatusStyles.modalButton,
                orderStatusStyles.modalConfirmButton,
              ]}
              onPress={submitCancellation}
            >
              <Text style={orderStatusStyles.modalConfirmText}>Submit</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );

  return (
    <Animated.View
      style={[
        orderStatusStyles.orderStatusContainer,
        {
          transform: [
            {
              translateY: slideAnim.interpolate({
                inputRange: [0, 1],
                outputRange: [0, Dimensions.get("window").height],
              }),
            },
          ],
        },
      ]}
    >
      {/* Header */}
      <View style={orderStatusStyles.orderStatusHeader}>
        <TouchableOpacity
          onPress={handleBackNavigation}
          style={orderStatusStyles.orderStatusSide}
        >
          <Ionicons
            name="arrow-back"
            size={25}
            color={ORDER_STATUS_COLORS.accent}
          />
        </TouchableOpacity>
        <Text style={orderStatusStyles.orderStatusHeaderTitle}>
          ORDER STATUS
        </Text>
        <View style={orderStatusStyles.orderStatusSide} />
      </View>

      <ScrollView 
        contentContainerStyle={{ alignItems: "center" }}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            colors={[ORDER_STATUS_COLORS.accent]}
            tintColor={ORDER_STATUS_COLORS.accent}
            title="Pull to refresh order status"
            titleColor={ORDER_STATUS_COLORS.accent}
          />
        }
      >
        <View style={orderStatusStyles.orderStatusCard}>
          {/* Order Number Display */}
          <Text style={orderStatusStyles.orderNumberText}>
            Order #{currentOrderNumber || "Loading..."}
          </Text>

          <Text style={orderStatusStyles.orderStatusDateText}>
            Ordered on {"\n"}
            {orderTime.toLocaleDateString(undefined, {
              year: "numeric",
              month: "long",
              day: "numeric",
            })}{" "}
            at{" "}
            {orderTime.toLocaleTimeString([], {
              hour: "2-digit",
              minute: "2-digit",
            })}
          </Text>

          <View style={{ alignSelf: "stretch", marginBottom: 15 }}>
            <Text style={orderStatusStyles.orderStatusSectionTitle}>
              Ordered Items
            </Text>
            {orderItems.length > 0 ? (
              orderItems.map((item, index) => (
                <View
                  key={index}
                  style={orderStatusStyles.orderStatusProductRow}
                >
                  <Image
                    source={{
                      uri: item.image || "https://via.placeholder.com/50",
                    }}
                    style={orderStatusStyles.orderStatusFoodImage}
                  />
                  <View style={{ flex: 1, marginLeft: 10 }}>
                    <Text style={orderStatusStyles.orderStatusProductText}>
                      {item.quantity}x {item.name} — ₱
                      {(item.quantity * item.price).toFixed(2)}
                    </Text>
                    <Text
                      style={[
                        orderStatusStyles.orderStatusProductText,
                        { fontSize: 12, color: "#666", marginTop: 2 },
                      ]}
                    >
                      Prep time: {item.prep_time} min
                    </Text>
                  </View>
                </View>
              ))
            ) : (
              <Text style={orderStatusStyles.orderStatusNoItemsText}>
                No items found
              </Text>
            )}
          </View>

          {/* Order Status Display */}
          {renderOrderStatus()}

          {/* Progress Steps */}
          {renderProgressSteps()}

          <View style={{ marginTop: 15, alignItems: "center" }}>
            <Text style={orderStatusStyles.orderStatusPaymentText}>
              Payment Method: {payment}
            </Text>
            <Text style={[
              orderStatusStyles.orderStatusPaymentText,
              { fontSize: 12, marginTop: 2, color: 
                paymentStatus === 'paid' ? ORDER_STATUS_COLORS.success :
                paymentStatus === 'failed' ? ORDER_STATUS_COLORS.danger :
                paymentStatus === 'processing' ? ORDER_STATUS_COLORS.orange :
                ORDER_STATUS_COLORS.grey
              }
            ]}>
              Payment Status: {paymentStatus.charAt(0).toUpperCase() + paymentStatus.slice(1)}
            </Text>
            <Text style={orderStatusStyles.orderStatusTotalText}>
              Total: ₱{parseFloat(total).toFixed(2)}
            </Text>
            <Text
              style={[
                orderStatusStyles.orderStatusPaymentText,
                { fontSize: 12, marginTop: 5 },
              ]}
            >
              Total prep time: {calculateETA} minutes
            </Text>
          </View>

          {/* Cancel Order Button (only if within time limit) */}
          {canCancelOrder() && (
            <TouchableOpacity
              style={orderStatusStyles.cancelOrderBtn}
              onPress={handleCancelOrder}
            >
              <Text style={orderStatusStyles.cancelOrderText}>
                CANCEL ORDER
              </Text>
            </TouchableOpacity>
          )}

          {/* Rate Order Button (only when received) */}
          {orderStatus === "received" && (
            <TouchableOpacity
              style={orderStatusStyles.orderStatusRateBtn}
              onPress={() =>
                router.push({
                  pathname: "/Feedback",
                  params: {
                    orderNumber: currentOrderNumber,
                    orderId: id,
                    orderItems: encodeURIComponent(JSON.stringify(orderItems)),
                    orderTotal: total,
                    paymentMethod: payment,
                    orderTime: time,
                  },
                })
              }
            >
              <Text style={orderStatusStyles.orderStatusRateText}>
                RATE ORDER
              </Text>
            </TouchableOpacity>
          )}
        </View>
      </ScrollView>

      {/* Modals */}
      {renderCancelModal()}
      {renderReasonModal()}
    </Animated.View>
  );
}
