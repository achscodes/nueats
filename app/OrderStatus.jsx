import React, { useEffect, useState, useMemo, useContext } from "react";
import {
  View,
  Text,
  TouchableOpacity,
  Image,
  Dimensions,
  ScrollView,
  Modal,
  Alert,
  Animated,
} from "react-native";
import { useRouter, useLocalSearchParams } from "expo-router";
import { Ionicons } from "@expo/vector-icons";
import orderStatusStyles, { ORDER_STATUS_COLORS } from "./src/OrderStatus.js";
import { getItemById } from "./demodata/menuDemoData.js";
import { OrderContext } from "./context/OrderContext";

const { width } = Dimensions.get("window");

export default function OrderStatus() {
  const router = useRouter();
  const params = useLocalSearchParams();
  const { createOrder, getTimeRemaining, getEstimatedReadyTime } =
    useContext(OrderContext);

  const {
    id = "1",
    time = new Date().toISOString(),
    status = "pending",
    items = "[]",
    total = "0",
    payment = "Cash",
    orderNumber = null, // ✅ Get orderNumber from params
  } = params;

  // ✅ REMOVED: Don't generate order number here - use the one from params
  // If no orderNumber in params, it will be generated by OrderContext.createOrder()

  // Parse order items safely with menu data lookup
  const orderItems = useMemo(() => {
    try {
      const decoded =
        typeof items === "string" ? decodeURIComponent(items) : items;
      const parsed =
        typeof decoded === "string" ? JSON.parse(decoded) : decoded;

      if (!Array.isArray(parsed)) return [];

      return parsed.map((item) => {
        // Get full item data from menu
        const menuItem = getItemById(item.id);

        return {
          ...item,
          quantity: Number(item.quantity) || 1,
          price: Number(item.price) || 0,
          prep_time: menuItem ? menuItem.prep_time : 15, // fallback to 15 min if not found
          name: menuItem ? menuItem.name : item.name,
          image: menuItem ? menuItem.image : item.image,
        };
      });
    } catch {
      return [];
    }
  }, [items]);

  // Parse order time
  const orderTime = useMemo(() => {
    const parsed = Date.parse(time);
    return !isNaN(parsed) ? new Date(parsed) : new Date();
  }, [time]);

  // Calculate ETA based on actual prep times
  const calculateETA = useMemo(() => {
    if (orderItems.length === 0) return 15; // Default 15 minutes if no items

    // Find the maximum prep time among all items (since they can be prepared in parallel)
    const maxPrepTime = Math.max(...orderItems.map((item) => item.prep_time));

    // Add base queue/setup time (2-5 minutes depending on queue position)
    const orderPosition = Number(id) || 1;
    const queueTime = Math.min(2 + (orderPosition - 1) * 2, 10); // Max 10 min queue time

    // Total ETA is max prep time + queue time
    return maxPrepTime + queueTime;
  }, [orderItems, id]);

  const estimatedReadyTime = useMemo(
    () => new Date(orderTime.getTime() + calculateETA * 60000),
    [orderTime, calculateETA]
  );

  // State management
  const [remaining, setRemaining] = useState(0);
  const [orderStatus, setOrderStatus] = useState(status);
  const [showCancelModal, setShowCancelModal] = useState(false);
  const [showReasonModal, setShowReasonModal] = useState(false);
  const [selectedReason, setSelectedReason] = useState("");
  const [currentOrderNumber, setCurrentOrderNumber] = useState(orderNumber); // ✅ Store order number in state

  // Animation for sliding to bottom
  const slideAnim = new Animated.Value(0);

  // Initialize order in context and set up countdown
  useEffect(() => {
    const orderData = {
      id,
      items: orderItems,
      total: parseFloat(total),
      payment,
      status: orderStatus,
      time,
      prepTime: calculateETA,
      orderNumber: currentOrderNumber, // ✅ Pass the existing order number (or null to generate new one)
    };

    // ✅ Create order and get the final order with generated number if needed
    const finalOrder = createOrder(orderData);

    // ✅ If we didn't have an order number, store the generated one
    if (!currentOrderNumber && finalOrder.orderNumber) {
      setCurrentOrderNumber(finalOrder.orderNumber);
    }
  }, []);

  // Update countdown using context method
  useEffect(() => {
    if (orderStatus === "preparing" || orderStatus === "pending") {
      const updateCountdown = () => {
        const timeLeft = getTimeRemaining();
        setRemaining(timeLeft);
      };

      // Update immediately
      updateCountdown();

      // Then update every second
      const interval = setInterval(updateCountdown, 1000);
      return () => clearInterval(interval);
    }
  }, [orderStatus, getTimeRemaining]);

  // Handle back navigation with order state preservation
  const handleBackNavigation = () => {
    // Update the order in context with current status
    const orderData = {
      id,
      items: orderItems,
      total: parseFloat(total),
      payment,
      status: orderStatus,
      time,
      prepTime: calculateETA,
      orderNumber: currentOrderNumber, // ✅ Use the stored order number
    };

    createOrder(orderData);

    // Animate sliding down before navigation
    Animated.timing(slideAnim, {
      toValue: 1,
      duration: 300,
      useNativeDriver: true,
    }).start(() => {
      router.replace({
        pathname: "/Menu",
        params: {
          fromOrderStatus: "true",
          // Pass order details as backup params
          orderId: id,
          orderStatus: orderStatus,
          orderTime: time,
          orderItems: encodeURIComponent(JSON.stringify(orderItems)),
          orderTotal: total,
          paymentMethod: payment,
          orderNumber: currentOrderNumber, // ✅ Pass the stored order number
        },
      });
    });
  };

  // Override hardware back button
  useEffect(() => {
    const backHandler = () => {
      handleBackNavigation();
      return true; // Prevent default back behavior
    };

    // Add event listener for hardware back button (Android)
    if (typeof window !== "undefined" && window.addEventListener) {
      window.addEventListener("beforeunload", backHandler);
    }

    return () => {
      if (typeof window !== "undefined" && window.removeEventListener) {
        window.removeEventListener("beforeunload", backHandler);
      }
    };
  }, []);

  const formatTime = (seconds) => {
    const m = Math.floor(seconds / 60);
    const s = seconds % 60;
    return `${m}:${s < 10 ? "0" : ""}${s}`;
  };

  const formatEstimatedTime = () => {
    const readyTime = getEstimatedReadyTime();
    if (!readyTime) return "N/A";

    return readyTime.toLocaleTimeString([], {
      hour: "2-digit",
      minute: "2-digit",
      hour12: true,
    });
  };

  // Check if order can be cancelled (within 5 minutes)
  const canCancelOrder = () => {
    const currentTime = new Date();
    const timeDiff = (currentTime - orderTime) / 1000 / 60; // minutes
    return (
      timeDiff <= 5 &&
      (orderStatus === "preparing" || orderStatus === "pending")
    );
  };

  // Test button handlers
  const handleMakeReady = () => {
    setOrderStatus("ready");
    setRemaining(0);
  };

  const handleMakeCancelled = () => {
    setOrderStatus("cancelled");
  };

  const handleMarkReceived = () => {
    setOrderStatus("received");
  };

  // Cancel order handlers
  const handleCancelOrder = () => {
    if (canCancelOrder()) {
      setShowCancelModal(true);
    } else {
      Alert.alert(
        "Cannot Cancel",
        "Orders can only be cancelled within 5 minutes of ordering."
      );
    }
  };

  const confirmCancelOrder = () => {
    setShowCancelModal(false);
    setShowReasonModal(true);
  };

  const submitCancellation = () => {
    if (!selectedReason) {
      Alert.alert(
        "Please select a reason",
        "Please provide a reason for cancelling your order."
      );
      return;
    }

    setOrderStatus("cancelled");
    setShowReasonModal(false);
    Alert.alert(
      "Order Cancelled",
      "Your order has been cancelled successfully."
    );
  };

  const cancelReasons = [
    "Changed my mind",
    "Found a better option",
    "Taking too long",
    "Emergency came up",
    "Wrong items ordered",
    "Other",
  ];

  // Render order status display
  const renderOrderStatus = () => {
    switch (orderStatus) {
      case "preparing":
      case "pending":
        return (
          <>
            <Text style={orderStatusStyles.orderStatusEtaText}>
              {formatTime(remaining)}
            </Text>
            <Text style={orderStatusStyles.orderStatusEtaLabel}>
              Estimated ready by {formatEstimatedTime()}
            </Text>
          </>
        );
      case "ready":
        return (
          <>
            <Text style={orderStatusStyles.orderStatusEtaText}>READY!</Text>
            <Text style={orderStatusStyles.orderStatusEtaLabel}>
              You can now pick up your order
            </Text>
          </>
        );
      case "received":
        return (
          <>
            <Text style={orderStatusStyles.orderStatusEtaText}>RECEIVED!</Text>
            <Text style={orderStatusStyles.orderStatusEtaLabel}>
              Order has been received
            </Text>
          </>
        );
      case "cancelled":
        return (
          <>
            <Text
              style={[
                orderStatusStyles.orderStatusEtaText,
                { color: ORDER_STATUS_COLORS.danger },
              ]}
            >
              CANCELLED
            </Text>
            <Text style={orderStatusStyles.orderStatusEtaLabel}>
              Your order is cancelled
            </Text>
          </>
        );
      default:
        return (
          <>
            <Text style={orderStatusStyles.orderStatusEtaText}>
              {formatTime(remaining)}
            </Text>
            <Text style={orderStatusStyles.orderStatusEtaLabel}>
              Estimated ready by {formatEstimatedTime()}
            </Text>
          </>
        );
    }
  };

  // Render progress steps
  const renderProgressSteps = () => {
    return (
      <View style={orderStatusStyles.orderStatusProgress}>
        <View style={orderStatusStyles.orderStatusStep}>
          <View
            style={[
              orderStatusStyles.orderStatusDot,
              (orderStatus === "preparing" || orderStatus === "pending") && {
                backgroundColor: ORDER_STATUS_COLORS.orange,
              },
            ]}
          />
          <Text style={orderStatusStyles.orderStatusStepText}>
            Your order is being prepared
          </Text>
        </View>
        <View style={orderStatusStyles.orderStatusStep}>
          <View
            style={[
              orderStatusStyles.orderStatusDot,
              orderStatus === "ready" && {
                backgroundColor: ORDER_STATUS_COLORS.green,
              },
            ]}
          />
          <Text style={orderStatusStyles.orderStatusStepText}>
            You can now pick up your order
          </Text>
        </View>
        <View style={orderStatusStyles.orderStatusStep}>
          <View
            style={[
              orderStatusStyles.orderStatusDot,
              orderStatus === "received" && {
                backgroundColor: ORDER_STATUS_COLORS.green,
              },
            ]}
          />
          <Text style={orderStatusStyles.orderStatusStepText}>
            Order has been received
          </Text>
        </View>
        {orderStatus === "cancelled" && (
          <View style={orderStatusStyles.orderStatusStep}>
            <View
              style={[
                orderStatusStyles.orderStatusDot,
                { backgroundColor: ORDER_STATUS_COLORS.danger },
              ]}
            />
            <Text style={orderStatusStyles.orderStatusStepText}>
              Your order is cancelled
            </Text>
          </View>
        )}
      </View>
    );
  };

  // Render test buttons (only in development)
  const renderTestButtons = () => {
    const isDevelopment = __DEV__ || true; // Always show for testing

    if (!isDevelopment) return null;

    return (
      <View style={orderStatusStyles.testButtonsContainer}>
        <Text style={orderStatusStyles.testButtonsTitle}>
          Test Controls (Dev Only)
        </Text>
        <View style={orderStatusStyles.testButtonsRow}>
          <TouchableOpacity
            style={[
              orderStatusStyles.testButton,
              { backgroundColor: ORDER_STATUS_COLORS.orange },
            ]}
            onPress={handleMakeReady}
          >
            <Text style={orderStatusStyles.testButtonText}>Make Ready</Text>
          </TouchableOpacity>
          <TouchableOpacity
            style={[
              orderStatusStyles.testButton,
              { backgroundColor: ORDER_STATUS_COLORS.danger },
            ]}
            onPress={handleMakeCancelled}
          >
            <Text style={orderStatusStyles.testButtonText}>Cancel Order</Text>
          </TouchableOpacity>
        </View>
        {orderStatus === "ready" && (
          <TouchableOpacity
            style={[
              orderStatusStyles.testButton,
              { backgroundColor: ORDER_STATUS_COLORS.green },
            ]}
            onPress={handleMarkReceived}
          >
            <Text style={orderStatusStyles.testButtonText}>Mark Received</Text>
          </TouchableOpacity>
        )}
      </View>
    );
  };

  // Render cancel confirmation modal
  const renderCancelModal = () => (
    <Modal
      animationType="fade"
      transparent={true}
      visible={showCancelModal}
      onRequestClose={() => setShowCancelModal(false)}
    >
      <View style={orderStatusStyles.modalOverlay}>
        <View style={orderStatusStyles.modalContainer}>
          <Text style={orderStatusStyles.modalTitle}>Cancel Order</Text>
          <Text style={orderStatusStyles.modalText}>
            Are you sure you want to cancel your order?
          </Text>
          <View style={orderStatusStyles.modalButtons}>
            <TouchableOpacity
              style={[
                orderStatusStyles.modalButton,
                orderStatusStyles.modalCancelButton,
              ]}
              onPress={() => setShowCancelModal(false)}
            >
              <Text style={orderStatusStyles.modalCancelText}>No</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[
                orderStatusStyles.modalButton,
                orderStatusStyles.modalConfirmButton,
              ]}
              onPress={confirmCancelOrder}
            >
              <Text style={orderStatusStyles.modalConfirmText}>Yes</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );

  // Render reason selection modal
  const renderReasonModal = () => (
    <Modal
      animationType="slide"
      transparent={true}
      visible={showReasonModal}
      onRequestClose={() => setShowReasonModal(false)}
    >
      <View style={orderStatusStyles.modalOverlay}>
        <View style={orderStatusStyles.modalContainer}>
          <Text style={orderStatusStyles.modalTitle}>
            Reason for Cancellation
          </Text>
          <Text style={orderStatusStyles.modalText}>
            Please select a reason for cancelling your order:
          </Text>
          <ScrollView style={orderStatusStyles.reasonsList}>
            {cancelReasons.map((reason, index) => (
              <TouchableOpacity
                key={index}
                style={[
                  orderStatusStyles.reasonItem,
                  selectedReason === reason &&
                    orderStatusStyles.reasonItemSelected,
                ]}
                onPress={() => setSelectedReason(reason)}
              >
                <View style={orderStatusStyles.radioContainer}>
                  <View style={orderStatusStyles.radioCircle}>
                    {selectedReason === reason && (
                      <View style={orderStatusStyles.radioDot} />
                    )}
                  </View>
                  <Text style={orderStatusStyles.reasonText}>{reason}</Text>
                </View>
              </TouchableOpacity>
            ))}
          </ScrollView>
          <View style={orderStatusStyles.modalButtons}>
            <TouchableOpacity
              style={[
                orderStatusStyles.modalButton,
                orderStatusStyles.modalCancelButton,
              ]}
              onPress={() => {
                setShowReasonModal(false);
                setSelectedReason("");
              }}
            >
              <Text style={orderStatusStyles.modalCancelText}>Cancel</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[
                orderStatusStyles.modalButton,
                orderStatusStyles.modalConfirmButton,
              ]}
              onPress={submitCancellation}
            >
              <Text style={orderStatusStyles.modalConfirmText}>Submit</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );

  return (
    <Animated.View
      style={[
        orderStatusStyles.orderStatusContainer,
        {
          transform: [
            {
              translateY: slideAnim.interpolate({
                inputRange: [0, 1],
                outputRange: [0, Dimensions.get("window").height],
              }),
            },
          ],
        },
      ]}
    >
      {/* Header */}
      <View style={orderStatusStyles.orderStatusHeader}>
        <TouchableOpacity
          onPress={handleBackNavigation}
          style={orderStatusStyles.orderStatusSide}
        >
          <Ionicons
            name="arrow-back"
            size={25}
            color={ORDER_STATUS_COLORS.accent}
          />
        </TouchableOpacity>
        <Text style={orderStatusStyles.orderStatusHeaderTitle}>
          ORDER STATUS
        </Text>
        <View style={orderStatusStyles.orderStatusSide} />
      </View>

      <ScrollView contentContainerStyle={{ alignItems: "center" }}>
        <View style={orderStatusStyles.orderStatusCard}>
          {/* Order Number Display */}
          <Text style={orderStatusStyles.orderNumberText}>
            Order #{currentOrderNumber || "Loading..."}
          </Text>

          <Text style={orderStatusStyles.orderStatusDateText}>
            Ordered on {"\n"}
            {orderTime.toLocaleDateString(undefined, {
              year: "numeric",
              month: "long",
              day: "numeric",
            })}{" "}
            at{" "}
            {orderTime.toLocaleTimeString([], {
              hour: "2-digit",
              minute: "2-digit",
            })}
          </Text>

          <View style={{ alignSelf: "stretch", marginBottom: 15 }}>
            <Text style={orderStatusStyles.orderStatusSectionTitle}>
              Ordered Items
            </Text>
            {orderItems.length > 0 ? (
              orderItems.map((item, index) => (
                <View
                  key={index}
                  style={orderStatusStyles.orderStatusProductRow}
                >
                  <Image
                    source={{
                      uri: item.image || "https://via.placeholder.com/50",
                    }}
                    style={orderStatusStyles.orderStatusFoodImage}
                  />
                  <View style={{ flex: 1, marginLeft: 10 }}>
                    <Text style={orderStatusStyles.orderStatusProductText}>
                      {item.quantity}x {item.name} — ₱
                      {(item.quantity * item.price).toFixed(2)}
                    </Text>
                    <Text
                      style={[
                        orderStatusStyles.orderStatusProductText,
                        { fontSize: 12, color: "#666", marginTop: 2 },
                      ]}
                    >
                      Prep time: {item.prep_time} min
                    </Text>
                  </View>
                </View>
              ))
            ) : (
              <Text style={orderStatusStyles.orderStatusNoItemsText}>
                No items found
              </Text>
            )}
          </View>

          {/* Order Status Display */}
          {renderOrderStatus()}

          {/* Progress Steps */}
          {renderProgressSteps()}

          <View style={{ marginTop: 15, alignItems: "center" }}>
            <Text style={orderStatusStyles.orderStatusPaymentText}>
              Payment Method: {payment}
            </Text>
            <Text style={orderStatusStyles.orderStatusTotalText}>
              Total: ₱{parseFloat(total).toFixed(2)}
            </Text>
            <Text
              style={[
                orderStatusStyles.orderStatusPaymentText,
                { fontSize: 12, marginTop: 5 },
              ]}
            >
              Total prep time: {calculateETA} minutes
            </Text>
          </View>

          {/* Cancel Order Button (only if within time limit) */}
          {canCancelOrder() && (
            <TouchableOpacity
              style={orderStatusStyles.cancelOrderBtn}
              onPress={handleCancelOrder}
            >
              <Text style={orderStatusStyles.cancelOrderText}>
                CANCEL ORDER
              </Text>
            </TouchableOpacity>
          )}

          {/* Rate Order Button (only when received) */}
          {orderStatus === "received" && (
            <TouchableOpacity
              style={orderStatusStyles.orderStatusRateBtn}
              onPress={() =>
                router.push({
                  pathname: "/Feedback",
                  params: {
                    orderNumber: currentOrderNumber,
                    orderId: id,
                    orderItems: encodeURIComponent(JSON.stringify(orderItems)),
                    orderTotal: total,
                    paymentMethod: payment,
                    orderTime: time,
                  },
                })
              }
            >
              <Text style={orderStatusStyles.orderStatusRateText}>
                RATE ORDER
              </Text>
            </TouchableOpacity>
          )}

          {/* Test Buttons */}
          {renderTestButtons()}
        </View>
      </ScrollView>

      {/* Modals */}
      {renderCancelModal()}
      {renderReasonModal()}
    </Animated.View>
  );
}
