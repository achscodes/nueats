import React, { useEffect, useState, useMemo, useContext, useCallback, useRef } from "react";
import {
  View,
  Text,
  TouchableOpacity,
  Image,
  Dimensions,
  ScrollView,
  Modal,
  Alert,
  Animated,
  RefreshControl,
  TextInput,
  KeyboardAvoidingView,
  Platform,
} from "react-native";
import { useRouter, useLocalSearchParams } from "expo-router";
import { Ionicons } from "@expo/vector-icons";
import Icon from "react-native-vector-icons/FontAwesome";
import orderStatusStyles, { ORDER_STATUS_COLORS } from "./src/OrderStatus.js";
import { getItemById } from "./demodata/menuDemoData.js";
import { OrderContext } from "./context/OrderContext";
import { supabase } from "../lib/supabase";
import { useAuth } from "./context/AuthContext";

const { width } = Dimensions.get("window");

export default function OrderStatus() {
  const router = useRouter();
  const params = useLocalSearchParams();
  const { createOrder, getTimeRemaining, getEstimatedReadyTime, clearOrder } =
    useContext(OrderContext);
  const { user } = useAuth();

  const {
    id = "1",
    time = new Date().toISOString(),
    status = "pending",
    items = "[]",
    total = "0",
    payment = "Cash",
    orderNumber = null, // ✅ Get orderNumber from params
  } = params;

  // ✅ REMOVED: Don't generate order number here - use the one from params
  // If no orderNumber in params, it will be generated by OrderContext.createOrder()

  // Parse order items safely with menu data lookup
  const orderItems = useMemo(() => {
    try {
      const decoded =
        typeof items === "string" ? decodeURIComponent(items) : items;
      const parsed =
        typeof decoded === "string" ? JSON.parse(decoded) : decoded;

      if (!Array.isArray(parsed)) return [];

      return parsed.map((item) => {
        // Use the item data directly from the order (which comes from database)
        // The database already contains the correct item information
        return {
          ...item,
          quantity: Number(item.quantity) || 1,
          price: Number(item.price) || 0,
          prep_time: item.prep_time || 15, // Use prep_time from order data
          name: item.name || 'Unknown Item',
          image: item.image || 'https://via.placeholder.com/50',
        };
      });
    } catch {
      return [];
    }
  }, [items]);

  // Parse order time
  const orderTime = useMemo(() => {
    const parsed = Date.parse(time);
    return !isNaN(parsed) ? new Date(parsed) : new Date();
  }, [time]);

  // Calculate ETA based on actual prep times
  const calculateETA = useMemo(() => {
    if (orderItems.length === 0) return 15; // Default 15 minutes if no items

    // Find the maximum prep time among all items (since they can be prepared in parallel)
    const maxPrepTime = Math.max(...orderItems.map((item) => item.prep_time));

    // Add base queue/setup time (2-5 minutes depending on queue position)
    const orderPosition = Number(id) || 1;
    const queueTime = Math.min(2 + (orderPosition - 1) * 2, 10); // Max 10 min queue time

    // Total ETA is max prep time + queue time
    return maxPrepTime + queueTime;
  }, [orderItems, id]);

  const estimatedReadyTime = useMemo(
    () => new Date(orderTime.getTime() + calculateETA * 60000),
    [orderTime, calculateETA]
  );

  // State management
  const [remaining, setRemaining] = useState(0);
  const [orderStatus, setOrderStatus] = useState("pending"); // Force default to pending
  const [showCancelModal, setShowCancelModal] = useState(false);
  const [showReasonModal, setShowReasonModal] = useState(false);
  const [selectedReason, setSelectedReason] = useState("");
  const [currentOrderNumber, setCurrentOrderNumber] = useState(orderNumber || (id ? `NU-2025-${id}` : null)); // ✅ Use NU-2025-{order_id} fallback
  const [refreshing, setRefreshing] = useState(false);
  const [paymentStatus, setPaymentStatus] = useState("pending");
  
  // Rating state
  const [orderRating, setOrderRating] = useState(null);
  const [showRatingModal, setShowRatingModal] = useState(false);
  const [ratingStars, setRatingStars] = useState(0);
  const [ratingFeedback, setRatingFeedback] = useState("");
  const [isSubmittingRating, setIsSubmittingRating] = useState(false);

  // Animation for sliding to bottom
  const slideAnim = new Animated.Value(0);
  
  // Ref to track if order has been initialized
  const orderInitialized = useRef(false);
  // Ref to track if timer has been started for preparing status
  const timerStarted = useRef(false);

  // Function to fetch latest order status from database
  const fetchOrderStatus = useCallback(async () => {
    try {
      if (!user?.id || !id) return;

      // Fetch order status
      const { data: orderData, error: orderError } = await supabase
        .from('orders')
        .select('status, updated_at')
        .eq('order_id', Number(id))
        .eq('user_id', user.id)
        .maybeSingle();

      if (orderError) {
        console.error('Error fetching order status:', orderError);
        return;
      }

      if (orderData) {
        // Map database status to app status
        const dbStatusMap = {
          'Pending': 'pending',
          'Preparing': 'preparing',
          'Ready': 'ready',
          'Completed': 'received',
          'Cancelled': 'cancelled'
        };
        
        const newStatus = dbStatusMap[orderData.status] || orderData.status.toLowerCase();
        setOrderStatus(newStatus);
      }

      // Fetch payment status
      const { data: paymentData, error: paymentError } = await supabase
        .from('payments')
        .select('status, provider_intent_id, provider_reference')
        .eq('order_id', Number(id))
        .eq('user_id', user.id)
        .maybeSingle();

      if (!paymentError && paymentData) {
        setPaymentStatus(paymentData.status);
      }
    } catch (error) {
      console.error('Error in fetchOrderStatus:', error);
    }
  }, [user?.id, id]);

  // Fetch rating for this order
  const fetchOrderRating = useCallback(async () => {
    try {
      const { data, error } = await supabase
        .from('ratings')
        .select('rating_id, stars, feedback, created_at')
        .eq('order_id', Number(id))
        .maybeSingle();
      
      if (error) {
        console.error('Error fetching rating:', error);
        setOrderRating(null);
        return;
      }
      
      setOrderRating(data || null);
      
      if (data) {
        setRatingStars(data.stars);
        setRatingFeedback(data.feedback || '');
      }
    } catch (error) {
      console.error('Error fetching rating:', error);
      setOrderRating(null);
    }
  }, [id]);

  // Check if rating is editable (within 30 days)
  const isRatingEditable = (createdAt) => {
    if (!createdAt) return false;
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    return new Date(createdAt) > thirtyDaysAgo;
  };

  // Submit rating
  const submitRating = async () => {
    if (ratingStars === 0) {
      Alert.alert('Rating Required', 'Please select a star rating.');
      return;
    }

    if (ratingFeedback.trim() === '') {
      Alert.alert('Feedback Required', 'Please provide your feedback.');
      return;
    }

    setIsSubmittingRating(true);
    try {
      const { error } = await supabase
        .from('ratings')
        .insert({
          order_id: Number(id),
          stars: ratingStars,
          feedback: ratingFeedback.trim(),
        });

      if (error) throw error;

      Alert.alert('Success', 'Thank you for your rating!');
      setShowRatingModal(false);
      await fetchOrderRating();
    } catch (error) {
      console.error('Error submitting rating:', error);
      Alert.alert('Error', error.message || 'Failed to submit rating');
    } finally {
      setIsSubmittingRating(false);
    }
  };

  // Update rating
  const updateRating = async () => {
    if (ratingStars === 0) {
      Alert.alert('Rating Required', 'Please select a star rating.');
      return;
    }

    if (ratingFeedback.trim() === '') {
      Alert.alert('Feedback Required', 'Please provide your feedback.');
      return;
    }

    setIsSubmittingRating(true);
    try {
      const { error } = await supabase
        .from('ratings')
        .update({
          stars: ratingStars,
          feedback: ratingFeedback.trim(),
        })
        .eq('rating_id', orderRating.rating_id);

      if (error) throw error;

      Alert.alert('Success', 'Rating updated successfully!');
      setShowRatingModal(false);
      await fetchOrderRating();
    } catch (error) {
      console.error('Error updating rating:', error);
      Alert.alert('Error', error.message || 'Failed to update rating');
    } finally {
      setIsSubmittingRating(false);
    }
  };

  // Pull to refresh handler
  const onRefresh = async () => {
    setRefreshing(true);
    await fetchOrderStatus();
    if (orderStatus === 'received') {
      await fetchOrderRating();
    }
    setRefreshing(false);
  };

  // Initialize order in context and set up countdown (only once)
  useEffect(() => {
    if (orderInitialized.current) return;
    
    const orderData = {
      id,
      items: orderItems,
      total: parseFloat(total),
      payment,
      status: orderStatus,
      time,
      prepTime: calculateETA,
      orderNumber: currentOrderNumber, // ✅ Pass the existing order number (or null to generate new one)
    };

    // ✅ Create order and get the final order with generated number if needed
    const finalOrder = createOrder(orderData);

    // ✅ If we didn't have an order number, store the generated one
    if (!currentOrderNumber && finalOrder.orderNumber) {
      setCurrentOrderNumber(finalOrder.orderNumber);
    }

    // Fetch initial order status from database
    fetchOrderStatus();
    
    // Mark as initialized
    orderInitialized.current = true;
  }, [id, orderItems, total, payment, orderStatus, time, calculateETA, currentOrderNumber]);

  // Auto-refresh order status every 10 seconds
  useEffect(() => {
    const interval = setInterval(() => {
      fetchOrderStatus();
    }, 10000); // Refresh every 10 seconds

    return () => clearInterval(interval);
  }, [id, user]);

  // Fetch rating when order status is received/completed
  useEffect(() => {
    if (orderStatus === 'received' && user?.id && id) {
      fetchOrderRating();
    }
  }, [orderStatus, user, id]);

  // Update countdown using context method
  useEffect(() => {
    if (orderStatus === "preparing") {
      // Only start timer once when status changes to preparing
      if (!timerStarted.current) {
        const orderData = {
          id,
          items: orderItems,
          total: parseFloat(total),
          payment,
          status: orderStatus,
          time,
          prepTime: calculateETA,
          orderNumber: currentOrderNumber,
        };
        createOrder(orderData);
        timerStarted.current = true;
      }

      const updateCountdown = () => {
        const timeLeft = getTimeRemaining();
        setRemaining(timeLeft);
      };

      // Update immediately
      updateCountdown();

      // Then update every second
      const interval = setInterval(updateCountdown, 1000);
      return () => clearInterval(interval);
    } else {
      // Reset timer started flag when not preparing
      timerStarted.current = false;
      // If not preparing, show full prep time
      setRemaining(calculateETA * 60);
    }
  }, [orderStatus, getTimeRemaining, calculateETA]);

  // Handle back navigation with order state preservation
  const handleBackNavigation = () => {
    // Animate sliding down before navigation
    Animated.timing(slideAnim, {
      toValue: 1,
      duration: 300,
      useNativeDriver: true,
    }).start(() => {
      router.replace({
        pathname: "/Menu",
        params: {
          fromOrderStatus: "true",
          // Pass order details as backup params
          orderId: id,
          orderStatus: orderStatus,
          orderTime: time,
          orderItems: encodeURIComponent(JSON.stringify(orderItems)),
          orderTotal: total,
          paymentMethod: payment,
          orderNumber: currentOrderNumber, // ✅ Pass the stored order number
        },
      });
    });
  };

  // Override hardware back button
  useEffect(() => {
    const backHandler = () => {
      handleBackNavigation();
      return true; // Prevent default back behavior
    };

    // Add event listener for hardware back button (Android)
    if (typeof window !== "undefined" && window.addEventListener) {
      window.addEventListener("beforeunload", backHandler);
    }

    return () => {
      if (typeof window !== "undefined" && window.removeEventListener) {
        window.removeEventListener("beforeunload", backHandler);
      }
    };
  }, []);

  const formatTime = (seconds) => {
    const m = Math.floor(seconds / 60);
    const s = seconds % 60;
    return `${m}:${s < 10 ? "0" : ""}${s}`;
  };

  const formatEstimatedTime = () => {
    const readyTime = getEstimatedReadyTime();
    if (!readyTime) return "N/A";

    return readyTime.toLocaleTimeString([], {
      hour: "2-digit",
      minute: "2-digit",
      hour12: true,
    });
  };

  // Check if order can be cancelled (within 5 minutes)
  const canCancelOrder = () => {
    const currentTime = new Date();
    const timeDiff = (currentTime - orderTime) / 1000 / 60; // minutes
    return (
      timeDiff <= 5 &&
      (orderStatus === "preparing" || orderStatus === "pending")
    );
  };

  // Cancel order handlers
  const handleCancelOrder = () => {
    if (canCancelOrder()) {
      setShowCancelModal(true);
    } else {
      Alert.alert(
        "Cannot Cancel",
        "Orders can only be cancelled within 5 minutes of ordering."
      );
    }
  };

  const confirmCancelOrder = () => {
    setShowCancelModal(false);
    setShowReasonModal(true);
  };

  const submitCancellation = async () => {
    if (!selectedReason) {
      Alert.alert(
        "Please select a reason",
        "Please provide a reason for cancelling your order."
      );
      return;
    }

    try {
      if (!user?.id) throw new Error("Not authenticated");

      // 1) Update order to Cancelled for this user (guard by user_id via RLS)
      const { error: orderErr } = await supabase
        .from("orders")
        .update({ status: "Cancelled" })
        .eq("order_id", Number(id));
      if (orderErr) throw orderErr;

      // 2) Update related payment to cancelled
      const { data: paymentRow, error: fetchPayErr } = await supabase
        .from("payments")
        .select("payment_id, status")
        .eq("order_id", Number(id))
        .eq("user_id", user.id)
        .maybeSingle();
      if (fetchPayErr) throw fetchPayErr;

      if (paymentRow?.payment_id) {
        const { error: payErr } = await supabase
          .from("payments")
          .update({ status: "cancelled" })
          .eq("payment_id", paymentRow.payment_id);
        if (payErr) throw payErr;

        // 3) Log payment event (client-side insert allowed by RLS)
        await supabase.from("payment_events").insert({
          payment_id: paymentRow.payment_id,
          provider: null,
          event_type: "client.cancelled",
          event_payload: { reason: selectedReason },
        });
      }

      // 4) Insert cancellation reason into order_cancellations table
      const { error: cancelErr } = await supabase
        .from("order_cancellations")
        .insert({
          order_id: Number(id),
          user_id: user.id,
          reason: selectedReason,
        });
      if (cancelErr) {
        console.error("Failed to log cancellation reason:", cancelErr);
        // Don't throw - cancellation already processed
      }

      setOrderStatus("cancelled");
      setShowReasonModal(false);
      
      // Clear order from context so it doesn't show in Menu
      clearOrder();
      
      Alert.alert(
        "Order Cancelled",
        "Your order has been cancelled successfully.",
        [
          {
            text: "OK",
            onPress: () => router.replace("/Menu"),
          },
        ]
      );
    } catch (e) {
      console.error("Cancellation failed", e);
      Alert.alert("Error", "Failed to cancel order. Please try again.");
    }
  };

  const cancelReasons = [
    "Changed my mind",
    "Found a better option",
    "Taking too long",
    "Emergency came up",
    "Wrong items ordered",
    "Other",
  ];

  // Render order status display
  const renderOrderStatus = () => {
    switch (orderStatus) {
      case "pending":
        return (
          <>
            <Text style={orderStatusStyles.orderStatusEtaText}>PENDING</Text>
            <Text style={orderStatusStyles.orderStatusEtaLabel}>
              Your order is being confirmed
            </Text>
          </>
        );
      case "preparing":
        return (
          <>
            <Text style={orderStatusStyles.orderStatusEtaText}>
              {formatTime(remaining)}
            </Text>
            <Text style={orderStatusStyles.orderStatusEtaLabel}>
              Estimated ready by {formatEstimatedTime()}
            </Text>
          </>
        );
      case "ready":
        return (
          <>
            <Text style={orderStatusStyles.orderStatusEtaText}>READY!</Text>
            <Text style={orderStatusStyles.orderStatusEtaLabel}>
              You can now pick up your order
            </Text>
          </>
        );
      case "received":
        return (
          <>
            <Text style={orderStatusStyles.orderStatusEtaText}>RECEIVED!</Text>
            <Text style={orderStatusStyles.orderStatusEtaLabel}>
              Order has been received
            </Text>
          </>
        );
      case "cancelled":
        return (
          <>
            <Text
              style={[
                orderStatusStyles.orderStatusEtaText,
                { color: ORDER_STATUS_COLORS.danger },
              ]}
            >
              CANCELLED
            </Text>
            <Text style={orderStatusStyles.orderStatusEtaLabel}>
              Your order is cancelled
            </Text>
          </>
        );
      default:
        return (
          <>
            <Text style={orderStatusStyles.orderStatusEtaText}>
              {formatTime(remaining)}
            </Text>
            <Text style={orderStatusStyles.orderStatusEtaLabel}>
              Estimated ready by {formatEstimatedTime()}
            </Text>
          </>
        );
    }
  };

  // Render progress steps
  const renderProgressSteps = () => {
    return (
      <View style={orderStatusStyles.orderStatusProgress}>
        <View style={orderStatusStyles.orderStatusStep}>
          <View
            style={[
              orderStatusStyles.orderStatusDot,
              orderStatus === "pending" && {
                backgroundColor: ORDER_STATUS_COLORS.orange,
              },
            ]}
          />
          <Text
            style={[
              orderStatusStyles.orderStatusStepText,
              orderStatus === "pending" && {
                fontWeight: "bold",
                color: ORDER_STATUS_COLORS.primary,
              },
            ]}
          >
            Your order is pending
          </Text>
        </View>
        <View style={orderStatusStyles.orderStatusStep}>
          <View
            style={[
              orderStatusStyles.orderStatusDot,
              orderStatus === "preparing" && {
                backgroundColor: ORDER_STATUS_COLORS.orange,
              },
            ]}
          />
          <Text
            style={[
              orderStatusStyles.orderStatusStepText,
              orderStatus === "preparing" && {
                fontWeight: "bold",
                color: ORDER_STATUS_COLORS.primary,
              },
            ]}
          >
            Your order is being prepared
          </Text>
        </View>
        <View style={orderStatusStyles.orderStatusStep}>
          <View
            style={[
              orderStatusStyles.orderStatusDot,
              orderStatus === "ready" && {
                backgroundColor: ORDER_STATUS_COLORS.green,
              },
            ]}
          />
          <Text
            style={[
              orderStatusStyles.orderStatusStepText,
              orderStatus === "ready" && {
                fontWeight: "bold",
                color: ORDER_STATUS_COLORS.primary,
              },
            ]}
          >
            You can now pick up your order
          </Text>
        </View>
        <View style={orderStatusStyles.orderStatusStep}>
          <View
            style={[
              orderStatusStyles.orderStatusDot,
              orderStatus === "received" && {
                backgroundColor: ORDER_STATUS_COLORS.green,
              },
            ]}
          />
          <Text
            style={[
              orderStatusStyles.orderStatusStepText,
              orderStatus === "received" && {
                fontWeight: "bold",
                color: ORDER_STATUS_COLORS.primary,
              },
            ]}
          >
            Order has been received
          </Text>
        </View>
        {orderStatus === "cancelled" && (
          <View style={orderStatusStyles.orderStatusStep}>
            <View
              style={[
                orderStatusStyles.orderStatusDot,
                { backgroundColor: ORDER_STATUS_COLORS.danger },
              ]}
            />
            <Text
              style={[
                orderStatusStyles.orderStatusStepText,
                { fontWeight: "bold", color: ORDER_STATUS_COLORS.danger },
              ]}
            >
              Your order is cancelled
            </Text>
          </View>
        )}
      </View>
    );
  };

  // Render cancel confirmation modal
  const renderCancelModal = () => (
    <Modal
      animationType="fade"
      transparent={true}
      visible={showCancelModal}
      onRequestClose={() => setShowCancelModal(false)}
    >
      <View style={orderStatusStyles.modalOverlay}>
        <View style={orderStatusStyles.modalContainer}>
          <Text style={orderStatusStyles.modalTitle}>Cancel Order</Text>
          <Text style={orderStatusStyles.modalText}>
            Are you sure you want to cancel your order?
          </Text>
          <View style={orderStatusStyles.modalButtons}>
            <TouchableOpacity
              style={[
                orderStatusStyles.modalButton,
                orderStatusStyles.modalCancelButton,
              ]}
              onPress={() => setShowCancelModal(false)}
            >
              <Text style={orderStatusStyles.modalCancelText}>No</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[
                orderStatusStyles.modalButton,
                orderStatusStyles.modalConfirmButton,
              ]}
              onPress={confirmCancelOrder}
            >
              <Text style={orderStatusStyles.modalConfirmText}>Yes</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );

  // Render reason selection modal
  const renderReasonModal = () => (
    <Modal
      animationType="slide"
      transparent={true}
      visible={showReasonModal}
      onRequestClose={() => setShowReasonModal(false)}
    >
      <View style={orderStatusStyles.modalOverlay}>
        <View style={orderStatusStyles.modalContainer}>
          <Text style={orderStatusStyles.modalTitle}>
            Reason for Cancellation
          </Text>
          <Text style={orderStatusStyles.modalText}>
            Please select a reason for cancelling your order:
          </Text>
          <ScrollView style={orderStatusStyles.reasonsList}>
            {cancelReasons.map((reason, index) => (
              <TouchableOpacity
                key={index}
                style={[
                  orderStatusStyles.reasonItem,
                  selectedReason === reason &&
                    orderStatusStyles.reasonItemSelected,
                ]}
                onPress={() => setSelectedReason(reason)}
              >
                <View style={orderStatusStyles.radioContainer}>
                  <View style={orderStatusStyles.radioCircle}>
                    {selectedReason === reason && (
                      <View style={orderStatusStyles.radioDot} />
                    )}
                  </View>
                  <Text style={orderStatusStyles.reasonText}>{reason}</Text>
                </View>
              </TouchableOpacity>
            ))}
          </ScrollView>
          <View style={orderStatusStyles.modalButtons}>
            <TouchableOpacity
              style={[
                orderStatusStyles.modalButton,
                orderStatusStyles.modalCancelButton,
              ]}
              onPress={() => {
                setShowReasonModal(false);
                setSelectedReason("");
              }}
            >
              <Text style={orderStatusStyles.modalCancelText}>Cancel</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[
                orderStatusStyles.modalButton,
                orderStatusStyles.modalConfirmButton,
              ]}
              onPress={submitCancellation}
            >
              <Text style={orderStatusStyles.modalConfirmText}>Submit</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );

  return (
    <Animated.View
      style={[
        orderStatusStyles.orderStatusContainer,
        {
          transform: [
            {
              translateY: slideAnim.interpolate({
                inputRange: [0, 1],
                outputRange: [0, Dimensions.get("window").height],
              }),
            },
          ],
        },
      ]}
    >
      {/* Header */}
      <View style={orderStatusStyles.orderStatusHeader}>
        <TouchableOpacity
          onPress={handleBackNavigation}
          style={orderStatusStyles.orderStatusSide}
        >
          <Ionicons
            name="arrow-back"
            size={25}
            color={ORDER_STATUS_COLORS.accent}
          />
        </TouchableOpacity>
        <Text style={orderStatusStyles.orderStatusHeaderTitle}>
          ORDER STATUS
        </Text>
        <View style={orderStatusStyles.orderStatusSide} />
      </View>

      <ScrollView 
        contentContainerStyle={{ alignItems: "center" }}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            colors={[ORDER_STATUS_COLORS.accent]}
            tintColor={ORDER_STATUS_COLORS.accent}
            title="Pull to refresh order status"
            titleColor={ORDER_STATUS_COLORS.accent}
          />
        }
      >
        <View style={orderStatusStyles.orderStatusCard}>
          {/* Order Number Display */}
          <Text style={orderStatusStyles.orderNumberText}>
            Order #{currentOrderNumber || "Loading..."}
          </Text>

          <Text style={orderStatusStyles.orderStatusDateText}>
            Ordered on {"\n"}
            {orderTime.toLocaleDateString(undefined, {
              year: "numeric",
              month: "long",
              day: "numeric",
            })}{" "}
            at{" "}
            {orderTime.toLocaleTimeString([], {
              hour: "2-digit",
              minute: "2-digit",
            })}
          </Text>

          <View style={{ alignSelf: "stretch", marginBottom: 15 }}>
            <Text style={orderStatusStyles.orderStatusSectionTitle}>
              Ordered Items
            </Text>
            {orderItems.length > 0 ? (
              orderItems.map((item, index) => (
                <View
                  key={index}
                  style={orderStatusStyles.orderStatusProductRow}
                >
                  <Image
                    source={{
                      uri: item.image || "https://via.placeholder.com/50",
                    }}
                    style={orderStatusStyles.orderStatusFoodImage}
                  />
                  <View style={{ flex: 1, marginLeft: 10 }}>
                    <Text style={orderStatusStyles.orderStatusProductText}>
                      {item.quantity}x {item.name} — ₱
                      {(item.quantity * item.price).toFixed(2)}
                    </Text>
                    <Text
                      style={[
                        orderStatusStyles.orderStatusProductText,
                        { fontSize: 12, color: "#666", marginTop: 2 },
                      ]}
                    >
                      Prep time: {item.prep_time} min
                    </Text>
                  </View>
                </View>
              ))
            ) : (
              <Text style={orderStatusStyles.orderStatusNoItemsText}>
                No items found
              </Text>
            )}
          </View>

          {/* Order Status Display */}
          {renderOrderStatus()}

          {/* Progress Steps */}
          {renderProgressSteps()}

          <View style={{ marginTop: 15, alignItems: "center" }}>
            <Text style={orderStatusStyles.orderStatusPaymentText}>
              Payment Method: {payment}
            </Text>
            <Text style={[
              orderStatusStyles.orderStatusPaymentText,
              { fontSize: 12, marginTop: 2, color: 
                paymentStatus === 'paid' ? ORDER_STATUS_COLORS.success :
                paymentStatus === 'failed' ? ORDER_STATUS_COLORS.danger :
                paymentStatus === 'processing' ? ORDER_STATUS_COLORS.orange :
                ORDER_STATUS_COLORS.grey
              }
            ]}>
              Payment Status: {paymentStatus.charAt(0).toUpperCase() + paymentStatus.slice(1)}
            </Text>
            <Text style={orderStatusStyles.orderStatusTotalText}>
              Total: ₱{parseFloat(total).toFixed(2)}
            </Text>
            <Text
              style={[
                orderStatusStyles.orderStatusPaymentText,
                { fontSize: 12, marginTop: 5 },
              ]}
            >
              Total prep time: {calculateETA} minutes
            </Text>
          </View>

          {/* Cancel Order Button (only if within time limit) */}
          {canCancelOrder() && (
            <TouchableOpacity
              style={orderStatusStyles.cancelOrderBtn}
              onPress={handleCancelOrder}
            >
              <Text style={orderStatusStyles.cancelOrderText}>
                CANCEL ORDER
              </Text>
            </TouchableOpacity>
          )}

          {/* Rating Section (only when received) */}
          {orderStatus === "received" && (
            <View style={{ marginTop: 15, paddingTop: 15, borderTopWidth: 1, borderTopColor: '#eee' }}>
              {!orderRating ? (
                // Show rating button if no rating exists
                <TouchableOpacity
                  style={orderStatusStyles.orderStatusRateBtn}
                  onPress={() => {
                    setRatingStars(0);
                    setRatingFeedback('');
                    setShowRatingModal(true);
                  }}
                >
                  <Text style={orderStatusStyles.orderStatusRateText}>
                    RATE ORDER
                  </Text>
                </TouchableOpacity>
              ) : (
                // Show existing rating
                <View>
                  <Text style={{ fontSize: 16, fontWeight: 'bold', color: '#2c3e91', marginBottom: 8 }}>
                    Your Rating
                  </Text>
                  <View style={{ flexDirection: 'row', marginBottom: 8 }}>
                    {[1, 2, 3, 4, 5].map((star) => (
                      <Icon
                        key={star}
                        name="star"
                        size={24}
                        color={star <= orderRating.stars ? '#FFD700' : '#ccc'}
                        style={{ marginRight: 4 }}
                      />
                    ))}
                  </View>
                  <Text style={{ fontSize: 14, color: '#666', marginBottom: 8 }}>
                    {orderRating.feedback}
                  </Text>
                  <Text style={{ fontSize: 12, color: '#999', marginBottom: 8 }}>
                    Rated on {new Date(orderRating.created_at).toLocaleDateString()}
                  </Text>
                  {isRatingEditable(orderRating.created_at) && (
                    <TouchableOpacity
                      style={{
                        backgroundColor: '#2c3e91',
                        padding: 10,
                        borderRadius: 5,
                        alignItems: 'center',
                      }}
                      onPress={() => {
                        setRatingStars(orderRating.stars);
                        setRatingFeedback(orderRating.feedback || '');
                        setShowRatingModal(true);
                      }}
                    >
                      <Text style={{ color: '#fff', fontWeight: 'bold' }}>
                        Edit Rating
                      </Text>
                    </TouchableOpacity>
                  )}
                </View>
              )}
            </View>
          )}
        </View>
      </ScrollView>

      {/* Modals */}
      {renderCancelModal()}
      {renderReasonModal()}
      
      {/* Rating Modal */}
      <Modal
        visible={showRatingModal}
        transparent={true}
        animationType="slide"
        onRequestClose={() => setShowRatingModal(false)}
      >
        <KeyboardAvoidingView
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={{ flex: 1 }}
        >
          <View style={{
            flex: 1,
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            justifyContent: 'center',
            alignItems: 'center',
            padding: 20,
          }}>
            <View style={{
              backgroundColor: '#fff',
              borderRadius: 15,
              padding: 20,
              width: '100%',
              maxWidth: 400,
            }}>
              <View style={{
                flexDirection: 'row',
                justifyContent: 'space-between',
                alignItems: 'center',
                marginBottom: 15,
              }}>
                <Text style={{ fontSize: 18, fontWeight: 'bold', color: '#2c3e91' }}>
                  {orderRating ? 'Edit Rating' : 'Rate Order'}
                </Text>
                <TouchableOpacity onPress={() => setShowRatingModal(false)}>
                  <Ionicons name="close" size={24} color="#666" />
                </TouchableOpacity>
              </View>

              <ScrollView showsVerticalScrollIndicator={false}>
                {/* Stars */}
                <View style={{ marginBottom: 15 }}>
                  <Text style={{ fontSize: 14, color: '#666', marginBottom: 8 }}>
                    How would you rate your order?
                  </Text>
                  <View style={{ flexDirection: 'row', justifyContent: 'center' }}>
                    {[1, 2, 3, 4, 5].map((star) => (
                      <TouchableOpacity
                        key={star}
                        onPress={() => setRatingStars(star)}
                        style={{ padding: 5 }}
                      >
                        <Icon
                          name="star"
                          size={40}
                          color={star <= ratingStars ? '#FFD700' : '#ccc'}
                        />
                      </TouchableOpacity>
                    ))}
                  </View>
                </View>

                {/* Feedback */}
                <View style={{ marginBottom: 15 }}>
                  <Text style={{ fontSize: 14, color: '#666', marginBottom: 8 }}>
                    Tell us about your experience
                  </Text>
                  <TextInput
                    style={{
                      borderWidth: 1,
                      borderColor: '#ddd',
                      borderRadius: 8,
                      padding: 10,
                      minHeight: 100,
                      textAlignVertical: 'top',
                    }}
                    placeholder="Share your feedback..."
                    placeholderTextColor="#999"
                    multiline
                    value={ratingFeedback}
                    onChangeText={setRatingFeedback}
                  />
                </View>

                {/* Submit Button */}
                <TouchableOpacity
                  style={{
                    backgroundColor: isSubmittingRating ? '#ccc' : '#2c3e91',
                    padding: 15,
                    borderRadius: 8,
                    alignItems: 'center',
                  }}
                  onPress={orderRating ? updateRating : submitRating}
                  disabled={isSubmittingRating}
                >
                  <Text style={{ color: '#fff', fontWeight: 'bold', fontSize: 16 }}>
                    {isSubmittingRating ? 'Submitting...' : (orderRating ? 'Update Rating' : 'Submit Rating')}
                  </Text>
                </TouchableOpacity>
              </ScrollView>
            </View>
          </View>
        </KeyboardAvoidingView>
      </Modal>
    </Animated.View>
  );
}
