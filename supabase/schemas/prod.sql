-- Orders and Order Items schema with RLS
-- Requires: Postgres UUID extension (enabled in Supabase by default)

-- Create orders table
create table if not exists public.orders (
  order_id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  total_amount numeric(12,2) not null check (total_amount >= 0),
  payment_method text not null check (payment_method in ('GCash','PayMaya','Cash','Paymongo')),
  status text not null check (status in ('Pending','Preparing','Ready','Completed','Cancelled')) default 'Pending',
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- Update updated_at automatically
create or replace function public.set_updated_at()
returns trigger language plpgsql as $$
begin
  new.updated_at = now();
  return new;
end; $$;

drop trigger if exists orders_set_updated_at on public.orders;
create trigger orders_set_updated_at
before update on public.orders
for each row execute procedure public.set_updated_at();

-- Create order_items table
create table if not exists public.order_items (
  order_item_id bigint generated by default as identity primary key,
  order_id bigint not null references public.orders(order_id) on delete cascade,
  product_id bigint not null references public.menu_items(id) on delete restrict,
  quantity integer not null check (quantity > 0),
  price numeric(12,2) not null check (price >= 0)
);

-- Helpful indexes
create index if not exists idx_orders_user_id on public.orders(user_id);
create index if not exists idx_order_items_order_id on public.order_items(order_id);
create index if not exists idx_order_items_product_id on public.order_items(product_id);

-- Enable RLS
alter table public.orders enable row level security;
alter table public.order_items enable row level security;

-- Policies for orders
-- Authenticated users can insert their own orders
drop policy if exists orders_insert_own on public.orders;
create policy orders_insert_own on public.orders
for insert to authenticated
with check (user_id = auth.uid());

-- Authenticated users can select their own orders
drop policy if exists orders_select_own on public.orders;
create policy orders_select_own on public.orders
for select to authenticated
using (user_id = auth.uid());

-- Authenticated users can update/cancel their own orders (Pending, Preparing, or Ready status)
drop policy if exists orders_update_own on public.orders;
create policy orders_update_own on public.orders
for update to authenticated
using (
  user_id = auth.uid() 
  AND status IN ('Pending', 'Preparing', 'Ready')
)
with check (
  user_id = auth.uid()
);

-- Admins can select and update all orders (expect an is_admin claim in JWT)
drop policy if exists orders_admin_all_select on public.orders;
create policy orders_admin_all_select on public.orders
for select to authenticated
using ((auth.jwt() ->> 'is_admin')::boolean is true);

drop policy if exists orders_admin_all_update on public.orders;
create policy orders_admin_all_update on public.orders
for update to authenticated
using ((auth.jwt() ->> 'is_admin')::boolean is true)
with check ((auth.jwt() ->> 'is_admin')::boolean is true);

-- Policies for order_items
-- Insert items only for orders owned by user
drop policy if exists order_items_insert_own_order on public.order_items;
create policy order_items_insert_own_order on public.order_items
for insert to authenticated
with check (exists (
  select 1 from public.orders o
  where o.order_id = order_items.order_id and o.user_id = auth.uid()
));

-- Select items only for orders owned by user
drop policy if exists order_items_select_own_order on public.order_items;
create policy order_items_select_own_order on public.order_items
for select to authenticated
using (exists (
  select 1 from public.orders o
  where o.order_id = order_items.order_id and o.user_id = auth.uid()
));

-- Update items only for orders owned by user
drop policy if exists order_items_update_own_order on public.order_items;
create policy order_items_update_own_order on public.order_items
for update to authenticated
using (exists (
  select 1 from public.orders o
  where o.order_id = order_items.order_id and o.user_id = auth.uid()
))
with check (exists (
  select 1 from public.orders o
  where o.order_id = order_items.order_id and o.user_id = auth.uid()
));

-- Admins can select/update all order_items
drop policy if exists order_items_admin_all_select on public.order_items;
create policy order_items_admin_all_select on public.order_items
for select to authenticated
using ((auth.jwt() ->> 'is_admin')::boolean is true);

drop policy if exists order_items_admin_all_update on public.order_items;
create policy order_items_admin_all_update on public.order_items
for update to authenticated
using ((auth.jwt() ->> 'is_admin')::boolean is true)
with check ((auth.jwt() ->> 'is_admin')::boolean is true);

-- Optional: prevent deletes by non-admins (omit delete policy). Admins can delete all
drop policy if exists orders_admin_delete_all on public.orders;
create policy orders_admin_delete_all on public.orders
for delete to authenticated
using ((auth.jwt() ->> 'is_admin')::boolean is true);

drop policy if exists order_items_admin_delete_all on public.order_items;
create policy order_items_admin_delete_all on public.order_items
for delete to authenticated
using ((auth.jwt() ->> 'is_admin')::boolean is true);

-- ==========================================
-- Payments schema and RLS
-- ==========================================

-- Create payments table
create table if not exists public.payments (
  payment_id bigint generated by default as identity primary key,
  order_id bigint not null references public.orders(order_id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  method text not null check (method in ('GCash','PayMaya','Cash')),
  amount numeric(12,2) not null check (amount >= 0),
  status text not null check (status in ('pending','processing','paid','failed','refunded','cancelled')) default 'pending',
  provider text,
  provider_intent_id text,
  provider_reference text,
  failure_reason text,
  metadata jsonb default '{}'::jsonb,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- Maintain updated_at
drop trigger if exists payments_set_updated_at on public.payments;
create trigger payments_set_updated_at
before update on public.payments
for each row execute procedure public.set_updated_at();

-- Optional: raw provider events for audit
create table if not exists public.payment_events (
  id bigint generated by default as identity primary key,
  payment_id bigint references public.payments(payment_id) on delete cascade,
  provider text,
  event_type text,
  event_payload jsonb not null,
  created_at timestamptz not null default now()
);

-- Enable RLS
alter table public.payments enable row level security;
alter table public.payment_events enable row level security;

-- Users: can insert/select/update their own pending/processing payments
drop policy if exists payments_insert_own on public.payments;
create policy payments_insert_own on public.payments
for insert to authenticated
with check (user_id = auth.uid());

drop policy if exists payments_select_own on public.payments;
create policy payments_select_own on public.payments
for select to authenticated
using (user_id = auth.uid());

drop policy if exists payments_update_own_pending on public.payments;
create policy payments_update_own_pending on public.payments
for update to authenticated
using (
  user_id = auth.uid() 
  AND status IN ('pending', 'processing', 'paid', 'failed')
)
with check (user_id = auth.uid());

-- Admins: full read/update
drop policy if exists payments_admin_select on public.payments;
create policy payments_admin_select on public.payments
for select to authenticated
using ((auth.jwt() ->> 'is_admin')::boolean is true);

drop policy if exists payments_admin_update on public.payments;
create policy payments_admin_update on public.payments
for update to authenticated
using ((auth.jwt() ->> 'is_admin')::boolean is true)
with check ((auth.jwt() ->> 'is_admin')::boolean is true);

-- Payment events policies
drop policy if exists payment_events_select_own on public.payment_events;
create policy payment_events_select_own on public.payment_events
for select to authenticated
using (exists (
  select 1 from public.payments p where p.payment_id = payment_events.payment_id and p.user_id = auth.uid()
));

drop policy if exists payment_events_admin_select on public.payment_events;
create policy payment_events_admin_select on public.payment_events
for select to authenticated
using ((auth.jwt() ->> 'is_admin')::boolean is true);

-- Allow users to insert events for their own payments (e.g., client-initiated cancellation logs)
drop policy if exists payment_events_insert_own on public.payment_events;
create policy payment_events_insert_own on public.payment_events
for insert to authenticated
with check (exists (
  select 1 from public.payments p where p.payment_id = payment_events.payment_id and p.user_id = auth.uid()
));

-- ==========================================
-- Order Cancellations schema and RLS
-- ==========================================

-- Create order_cancellations table
create table if not exists public.order_cancellations (
  cancellation_id bigint generated by default as identity primary key,
  order_id bigint not null references public.orders(order_id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  reason text not null,
  additional_notes text,
  cancelled_at timestamptz not null default now()
);

-- Create index for faster lookups
create index if not exists idx_order_cancellations_order_id on public.order_cancellations(order_id);
create index if not exists idx_order_cancellations_user_id on public.order_cancellations(user_id);

-- Enable RLS
alter table public.order_cancellations enable row level security;

-- Users can insert their own cancellations
drop policy if exists order_cancellations_insert_own on public.order_cancellations;
create policy order_cancellations_insert_own on public.order_cancellations
for insert to authenticated
with check (user_id = auth.uid() and exists (
  select 1 from public.orders o where o.order_id = order_cancellations.order_id and o.user_id = auth.uid()
));

-- Users can select their own cancellations
drop policy if exists order_cancellations_select_own on public.order_cancellations;
create policy order_cancellations_select_own on public.order_cancellations
for select to authenticated
using (user_id = auth.uid());

-- Admins can select all cancellations
drop policy if exists order_cancellations_admin_select on public.order_cancellations;
create policy order_cancellations_admin_select on public.order_cancellations
for select to authenticated
using ((auth.jwt() ->> 'is_admin')::boolean is true);


