-- Create ratings table
-- This table stores user ratings and feedback for completed orders

create table if not exists public.ratings (
  rating_id bigint generated by default as identity primary key,
  order_id bigint not null references public.orders(order_id) on delete cascade,
  stars integer not null check (stars >= 1 and stars <= 5),
  feedback text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  -- Ensure one rating per order
  unique(order_id)
);

-- Create index for faster lookups
create index if not exists idx_ratings_order_id on public.ratings(order_id);
create index if not exists idx_ratings_stars on public.ratings(stars);
create index if not exists idx_ratings_created_at on public.ratings(created_at desc);

-- Update updated_at automatically
drop trigger if exists ratings_set_updated_at on public.ratings;
create trigger ratings_set_updated_at
before update on public.ratings
for each row execute procedure public.set_updated_at();

-- Enable RLS
alter table public.ratings enable row level security;

-- Policy 1: Users can INSERT ratings ONLY for their own COMPLETED orders, ONE TIME per order
drop policy if exists "Users can rate their completed orders" on public.ratings;
create policy "Users can rate their completed orders"
  on public.ratings
  for insert
  to authenticated
  with check (
    exists (
      select 1 from public.orders o
      where o.order_id = ratings.order_id
        and o.user_id = auth.uid()
        and o.status = 'Completed'
    )
  );

-- Policy 2: Users can SELECT (view) their own ratings
drop policy if exists "Users can view their own ratings" on public.ratings;
create policy "Users can view their own ratings"
  on public.ratings
  for select
  to authenticated
  using (
    exists (
      select 1 from public.orders o
      where o.order_id = ratings.order_id
        and o.user_id = auth.uid()
    )
  );

-- Policy 3: Users can UPDATE their own ratings within 30 days
drop policy if exists "Users can update their own ratings" on public.ratings;
create policy "Users can update their own ratings"
  on public.ratings
  for update
  to authenticated
  using (
    exists (
      select 1 from public.orders o
      where o.order_id = ratings.order_id
        and o.user_id = auth.uid()
    )
    and created_at > now() - interval '30 days'
  )
  with check (
    exists (
      select 1 from public.orders o
      where o.order_id = ratings.order_id
        and o.user_id = auth.uid()
    )
  );

-- Policy 4: Admins can SELECT all ratings
drop policy if exists "Admins can view all ratings" on public.ratings;
create policy "Admins can view all ratings"
  on public.ratings
  for select
  to authenticated
  using (is_admin());

-- Policy 5: Admins can UPDATE all ratings (for moderation)
drop policy if exists "Admins can update all ratings" on public.ratings;
create policy "Admins can update all ratings"
  on public.ratings
  for update
  to authenticated
  using (is_admin())
  with check (is_admin());

-- Policy 6: Admins can DELETE ratings (for moderation)
drop policy if exists "Admins can delete ratings" on public.ratings;
create policy "Admins can delete ratings"
  on public.ratings
  for delete
  to authenticated
  using (is_admin());

