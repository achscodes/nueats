-- Create ratings table
-- This table stores user ratings and feedback for completed orders

create table if not exists public.ratings (
  rating_id bigint generated by default as identity primary key,
  order_id bigint not null references public.orders(order_id) on delete cascade,
  stars integer not null check (stars >= 1 and stars <= 5),
  feedback text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  -- Ensure one rating per order
  unique(order_id)
);

-- Create index for faster lookups
create index if not exists idx_ratings_order_id on public.ratings(order_id);
create index if not exists idx_ratings_stars on public.ratings(stars);
create index if not exists idx_ratings_created_at on public.ratings(created_at desc);

-- Update updated_at automatically
drop trigger if exists ratings_set_updated_at on public.ratings;
create trigger ratings_set_updated_at
before update on public.ratings
for each row execute procedure public.set_updated_at();

-- Enable RLS
alter table public.ratings enable row level security;

-- Policy 1: Users can INSERT ratings ONLY for their own COMPLETED orders, ONE TIME per order
drop policy if exists "Users can rate their completed orders" on public.ratings;
create policy "Users can rate their completed orders"
  on public.ratings
  for insert
  to authenticated
  with check (
    exists (
      select 1 from public.orders o
      where o.order_id = ratings.order_id
        and o.user_id = auth.uid()
        and o.status = 'Completed'
    )
  );

-- Policy 2: Users can SELECT (view) their own ratings
drop policy if exists "Users can view their own ratings" on public.ratings;
create policy "Users can view their own ratings"
  on public.ratings
  for select
  to authenticated
  using (
    exists (
      select 1 from public.orders o
      where o.order_id = ratings.order_id
        and o.user_id = auth.uid()
    )
  );

-- Policy 3: Users can UPDATE their own ratings within 30 days
drop policy if exists "Users can update their own ratings" on public.ratings;
create policy "Users can update their own ratings"
  on public.ratings
  for update
  to authenticated
  using (
    exists (
      select 1 from public.orders o
      where o.order_id = ratings.order_id
        and o.user_id = auth.uid()
    )
    and created_at > now() - interval '30 days'
  )
  with check (
    exists (
      select 1 from public.orders o
      where o.order_id = ratings.order_id
        and o.user_id = auth.uid()
    )
  );

-- Policy 4: Admins can SELECT all ratings
drop policy if exists "Admins can view all ratings" on public.ratings;
create policy "Admins can view all ratings"
  on public.ratings
  for select
  to authenticated
  using (is_admin());

-- Policy 5: Admins can UPDATE all ratings (for moderation)
drop policy if exists "Admins can update all ratings" on public.ratings;
create policy "Admins can update all ratings"
  on public.ratings
  for update
  to authenticated
  using (is_admin())
  with check (is_admin());

-- Policy 6: Admins can DELETE ratings (for moderation)
drop policy if exists "Admins can delete ratings" on public.ratings;
create policy "Admins can delete ratings"
  on public.ratings
  for delete
  to authenticated
  using (is_admin());

-- Create a function to get average rating for a menu item
create or replace function get_menu_item_avg_rating(item_id bigint)
returns numeric
language sql
stable
as $$
  select coalesce(avg(r.stars), 0)
  from public.ratings r
  join public.order_items oi on oi.order_id = r.order_id
  where oi.product_id = item_id;
$$;

-- Create a function to get total ratings count for a menu item
create or replace function get_menu_item_rating_count(item_id bigint)
returns bigint
language sql
stable
as $$
  select count(distinct r.rating_id)
  from public.ratings r
  join public.order_items oi on oi.order_id = r.order_id
  where oi.product_id = item_id;
$$;

-- Create a view for menu item ratings (useful for displaying on menu)
create or replace view menu_item_ratings as
select 
  mi.id as menu_item_id,
  mi.name as menu_item_name,
  count(distinct r.rating_id) as total_ratings,
  coalesce(avg(r.stars), 0) as average_stars,
  count(distinct case when r.stars = 5 then r.rating_id end) as five_star_count,
  count(distinct case when r.stars = 4 then r.rating_id end) as four_star_count,
  count(distinct case when r.stars = 3 then r.rating_id end) as three_star_count,
  count(distinct case when r.stars = 2 then r.rating_id end) as two_star_count,
  count(distinct case when r.stars = 1 then r.rating_id end) as one_star_count
from public.menu_items mi
left join public.order_items oi on oi.product_id = mi.id
left join public.ratings r on r.order_id = oi.order_id
group by mi.id, mi.name;

-- Comment on table and columns
comment on table public.ratings is 'User ratings and feedback for completed orders';
comment on column public.ratings.rating_id is 'Primary key';
comment on column public.ratings.order_id is 'Foreign key to orders table';
comment on column public.ratings.stars is 'Rating from 1 to 5 stars';
comment on column public.ratings.feedback is 'Optional text feedback from user';
comment on column public.ratings.created_at is 'When the rating was created';
comment on column public.ratings.updated_at is 'When the rating was last updated';

